# curving problem
## 개요
타원곡선의 서명 시스템을 익스하자.

## 풀이
_secp256k1.py_ 파일을 보면
```py
def verify(self, message:bytes, signature:bytes) -> bool:
	if self.public == None:
		raise ValueError('must have public key to verify')

	if self.order * self.public != self.O:
		raise ValueError('public key is wrong')
	
	if len(signature) != 64:
		return False

	r, s = int.from_bytes(signature[:32], 'big'), int.from_bytes(signature[32:], 'big')
	
	if r > (self.order - 1) or s > (self.order - 1):
		return False

	e = int(hashlib.sha256(message).hexdigest(), 16)
	u1 = (e * inverse(s, self.order)) % self.order
	u2 = (r * inverse(s, self.order)) % self.order
	U = (u1 * self.G) + (u2 * self.public)
	if U.x == r:
		return True
	else:
		return False
```
입력값을 받아서 서명 검증을 한다. 근데 이 코드의 맹점은 r, s가 둘다 0이면 조건문을 통과해버린다는 것이다.

스칼라 0에 점을 곱하게 되면 점은  가 되고, 이 점의 x좌표는 0이므로 문제가 어이없게 풀리게 된다.

```py
from pwn import *
from Crypto.Util.number import *
import hashlib

p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
a = 0
b = 7
gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
order = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

context.log_level = 'debug'

io = remote('52.231.190.63', 8287)

io.recvuntil('public key : ')
# r, s = eval(io.recvline())

io.recvuntil('input signature in hex format : ')

r = 0
e = int(hashlib.sha256(b'admin').hexdigest(), 16)
s = 0

io.sendline((b'\x00' * 64).hex())
io.interactive()
```

![alt](./res/XuRe7MO.png)
☑ cce2024{ba11e7366e15e6f05a4be64262328572caadb018360d361ab06c017b876667d754557b8461d87821e9d69291481a860e0467}