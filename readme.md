# B2T
## 개요
특정한 인코딩 방식을 이용해서 인코딩 한 텍스트 세트를 이용해, 플래그를 디코딩 시켜주면 된다.

## 풀이
문제 파일을 열어보면
flag.txt.encode, plain.txt, plain.txt.encode 이렇게 세 개의 파일이 주어진다.

![alt](./res/xLPFTky.png)

plain.txt 파일 내에는 영어 지문이 들어있는데 문제에 대한 힌트는 전혀 없으므로 넘겨준다.

우리가 주목해야 하는 것은 plain.txt, plain.txt.encode 파일의 길이
plain.txt.encode 파일에 사용된 중복되지 않는 문자의 개수
이다.

1번을 구해보면 3864, 5277이 각각 나오는데 여기서 이 두 숫자 사이의 관계에서 힌트를 얻을 수 있다.

문제가 그렇게 어렵지 않을 것이므로 문제에서의 인코딩 방식은 base64와 유사한 일대일 대응, 치환으로 이루어짐을 추측할 수 있고 총 문자의 개수가 증가했으므로

ascii code의 기본 진법인 256진법보다 작은, 어떤 진법에 의해 치환이 이루어져있음을 추측할 수 있고 정확한 modular 값을 구해보면 58이 나오는 것을 확인할 수 있다.

(256진법으로 3884자리의 수는 58진법으로 5277자리의 수이다.)

![alt](./res/1IjvrVS.png)
두번째로 plain.txt.encode에 사용된 문자의 종류를 프로그램을 짜서 세어보면 총 58개임을 알 수 있다.

여기서 58진법으로 인코딩을 돌리는 것이 자명하구나, 라고 확신할 수 있고 big endian 방식으로 주어진 텍스트 파일을 숫자로 변환한 뒤 바로 58진법으로 변환하여 일대일 대응 쌍을 만들게 되면 문제가 풀릴 것이라 생각했다.

그러나 Base58 인코딩에 대한 조사를 하고 나서 알게 된 점인데, 58진법으로 변환 후 한 자리가 뒤에서 앞으로 당겨져 오게 된다. 이를 알지 못하는 상태에서 아래와 같은 방법으로 문제를 해결하였다.

## 1. 문자 및 숫자 배포 빈도 추출하기
``` Py
from Crypto.Util.number import *
from collections import Counter

pt = open('plain.txt', 'r').read()
enc_pt = open('plain.txt.encode', 'r').read()
enc_flag = open('flag.txt.encode', 'r').read()

N = 58

npt = int.from_bytes(pt.encode(), 'big')
assert long_to_bytes(npt) == pt.encode() and len(pt.encode()) == 3864

d = {}
li = []
cnt = 0
while npt // N:
    li.append(npt % N)
    npt //= N

res = 0

li = li[::-1]
print(li)
enc_count = Counter(enc_pt)
li_count = Counter(li)

print(enc_count, li_count)
```
Counter 객체를 이용해서 리스트와 문자열의 문자 중복을 확인하면 숫자 분포가 대응된다는 것을 확인할 수 있다.

![alt](./res/KXB9sHj.png)
여기서 우리의 방향성은 틀리지 않음을 알 수 있다.

## 2. 최빈 문자 배치 확인하기, 그리고 쉬프트
```py
ali = []
bli = []

for i in range(len(enc_pt)):
    if enc_pt[i] == '6':
        ali.append(i)

for i in range(len(li)):
    if li[i] == 53:
        bli.append(i)

print(ali, bli)
```
![alt](./res/u1xbZSS.png)
배열의 인덱스 차이가 1 남을 확인했다. 이후 코드만 짜주면 문제가 풀린다.

_ex.py_
```py
from Crypto.Util.number import *
from collections import Counter

pt = open('plain.txt', 'r').read()
enc_pt = open('plain.txt.encode', 'r').read()
enc_flag = open('flag.txt.encode', 'r').read()

N = 58

npt = int.from_bytes(pt.encode(), 'big')
assert long_to_bytes(npt) == pt.encode() and len(pt.encode()) == 3864

d = {}
li = []
cnt = 0
while npt // N:
    li.append(npt % N)
    npt //= N

res = 0

li = li[::-1]
print(li)
enc_count = Counter(enc_pt)
li_count = Counter(li)

print(enc_count, li_count)

ali = []
bli = []

for i in range(len(enc_pt)):
    if enc_pt[i] == '6':
        ali.append(i)

for i in range(len(li)):
    if li[i] == 53:
        bli.append(i)

print(ali, bli)

li = li[-1:] + li[:-1]

for i in range(len(li)):
    d[enc_pt[i]] = li[i]

for i in range(len(enc_flag)):
    res += d[enc_flag[i]] * N ** (len(enc_flag) - i - 1)

print(long_to_bytes(res))
```

☑ cce2024{Ev3n_biTC0in_Use5_B4s358_F0r_Bin4rY_tO_t3XT_EnC0dIng}

# blobby blob
## 개요
문제에서 손상된 blob rsa 비밀키 파일을 준다. 이를 이용해서 암호문을 복호화하자.

## 풀이
아래 링크를 들어가보면 파일 구조에 대한 설명이 나와있고, 0x14 바이트까지 헤더 부분, 0x14바이트 부터 본문 부분임을 확인할 수 있다.

파일에서 N, p, q, d가 주어지는데 N의 크기를 k 바이트라 하면 p, q의 크기는 k/2바이트, d의 크기는 k 바이트로 총 3k 바이트이다.

0x14부터 주어진 파일 끝까지 총 길이가 0x300 바이트임을 알 수 있고 3등분을 하면 N, p를 온전하게 구해 낼 수 있다.

이후 N을 소인수분해 하고 RSA를 돌리면 풀린다.

_ex.py_
```py
from Crypto.Util.number import *

n = "8D 90 E3 33 BF 81 6D 33 F8 DC 0D 3F 77 AB F4 7F A2 B8 7E 84 32 7D E0 A8 3B B9 25 EC A5 3D 6E 57 04 53 7E 71 E7 3A 1A 0C 87 A7 78 9B 15 12 74 CE 83 66 15 59 73 6A 4B 3E 29 83 9D D7 94 CF A0 0C 11 9F 9E 11 0A B2 94 EF BC AB 73 07 39 4A A7 88 91 B2 82 94 BE E7 81 2F ED FF EA F1 04 45 3E 98 FB A9 CB 5E BE 35 E7 B2 46 6E F1 15 D6 1F E1 1A EE 59 65 C0 A2 FC 5A 6F 11 C8 13 C8 6C 67 4D 64 67 68 98 CF 65 2C 9D 1D 0E 47 FE 22 41 71 CC 1C CB 5B 28 35 AF DB 78 B1 F9 C0 C6 11 27 3F 6C 0E F7 17 C8 C7 AB 46 A6 85 AC 7F 1A B1 FA B6 36 0B E0 28 4F 1A E0 F0 25 56 64 F4 F7 13 DD E6 6D E4 33 01 E3 E1 E0 55 B0 67 C2 DF F9 9A B6 95 6B F9 29 E8 54 24 8C A6 D1 4A FA 8F 24 7B 99 2C BF F4 82 88 DD E8 3C 19 D6 E3 FB 05 FE 4B 03 51 6A 7E 21 B3 4B E9 BF 1C 35 42 E0 BE 18 38 56 97 DA A5".split(' ')
p = "23 E0 52 4B B2 5A FD B8 33 B5 16 0E AC DD 4C 67 E7 22 C8 F0 14 92 16 41 A2 88 8C C1 AE 96 55 11 AF 63 E8 B3 D8 27 CD D3 3D F3 E7 CC 89 6D 81 4E B0 D8 B0 EB B5 ED 1A 07 43 9B EA 62 1C 84 04 FE AF 95 CC 95 EE 58 D5 43 43 80 32 1B EF 37 D2 DC 5D 01 61 00 CA A3 34 32 2B A9 43 5E 12 62 29 91 50 F9 F7 F6 C9 56 5C E1 2E 5C 0F 54 AA CA E9 D5 A0 99 B7 79 FC EA 3C 72 F6 48 CF EB A4 9E 2E D8".split(' ')

n = [int(x, 16) for x in n]
p = [int(x, 16) for x in p]

n = int(bytes(n[::-1]).hex(), 16)
p = int(bytes(p[::-1]).hex(), 16)

assert n % p == 0

q = n // p

e = 0x10001

phi = (p - 1) * (q - 1)
d = inverse(e, phi)

ct = int("0x637237dc569b8f5028139b551b7d9b9ebb282e4c057edccebb47de219d5251c2a9b29bfb5325e37db9ff9056742a31e5dd286b441047675260e53d8549344b3c25c0bb9adffffd49f35236a384464bf5fa794b527fac2928e812a77fb4f10f231dfeab8b0a42dd59f9a6ab0ceae4c46e13227a196982c7c5202dd317a31895aa89a35fde5307432919e8339a213abd2a9b221d9d26154bb0576c77b6d10afd289c8a5f728b4e1d3ab4cf8ab74b15ae1e6bd423f1af65ad29deda565f2bb0b3330105edbe2fc21950d1757a27054e53b42395ee438ede97081c0cbed7211d9814648e6a24661f1915bd98bd5e92758310d8ffaefaf5a570864826574dca4c2b12", 16)

pt = pow(ct, d, n)

print(long_to_bytes(pt))
```
![alt](./res/2EZPHMO.png)
☑ cce2024{345Y_RSA_D3crYptI0n_U5ing_K3y_Bl0b}

# Ref
[https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wcce/5cf2e6b9-3195-4f85-bc18-05b50e6d4e11](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-wcce/5cf2e6b9-3195-4f85-bc18-05b50e6d4e11)


# curving problem
## 개요
타원곡선의 서명 시스템을 익스하자.

## 풀이
_secp256k1.py_ 파일을 보면
```py
def verify(self, message:bytes, signature:bytes) -> bool:
    if self.public == None:
        raise ValueError('must have public key to verify')

    if self.order * self.public != self.O:
        raise ValueError('public key is wrong')
    
    if len(signature) != 64:
        return False

    r, s = int.from_bytes(signature[:32], 'big'), int.from_bytes(signature[32:], 'big')
    
    if r > (self.order - 1) or s > (self.order - 1):
        return False

    e = int(hashlib.sha256(message).hexdigest(), 16)
    u1 = (e * inverse(s, self.order)) % self.order
    u2 = (r * inverse(s, self.order)) % self.order
    U = (u1 * self.G) + (u2 * self.public)
    if U.x == r:
        return True
    else:
        return False
```
입력값을 받아서 서명 검증을 한다. 근데 이 코드의 맹점은 r, s가 둘다 0이면 조건문을 통과해버린다는 것이다.

스칼라 0에 점을 곱하게 되면 점은  가 되고, 이 점의 x좌표는 0이므로 문제가 어이없게 풀리게 된다.

```py
from pwn import *
from Crypto.Util.number import *
import hashlib

p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
a = 0
b = 7
gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
order = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

context.log_level = 'debug'

io = remote('52.231.190.63', 8287)

io.recvuntil('public key : ')
# r, s = eval(io.recvline())

io.recvuntil('input signature in hex format : ')

r = 0
e = int(hashlib.sha256(b'admin').hexdigest(), 16)
s = 0

io.sendline((b'\x00' * 64).hex())
io.interactive()
```

![alt](./res/XuRe7MO.png)
☑ cce2024{ba11e7366e15e6f05a4be64262328572caadb018360d361ab06c017b876667d754557b8461d87821e9d69291481a860e0467}

# escape from
## 개요
ssh 접속하면 자동으로 vim이 실행되는데 탈출하고 플래그를 찾아야 한다.

## 풀이
` :!cat flag`를 바로 실행하였으나, 안된다. 그래서 쉘을 vim에서 실행하기 위해 `sh`를 실행했으나, 이도 안된다.

검색한 결과 `:term`을 이용하면 터미널로 진입이 가능해진다.

`:term bash`를 입력해서 bash를 실행하고 flag를 얻으면 된다.

![alt](./res/agR6G9h.png)

☑ cce2024{2dd5a3a616caaa7cd5b463582defc741a2c27f4b49e888d9dbf5ed2a805394de3d7f2fc4a9577e0e48b9aa2cb516b8e1fc84f6f777b2196ac8b507}

# timetravel
## 개요
ctf가 끝나면 열리는 플래그를 passcord를 입력해서 얻어야 한다.

## 풀이
iconv를 사용한다는걸 알 수 있는데, 함수 호출시에 방샐하는 범위를 벗어나게 쓰는 것이 가능한 취약점이 존재한다 (CVE-2024-2961)

iconv를 사용하면 3바이트에서 4바이트로 오버플로우가 일어나는 취약점이 존재하고, 이를 이용해서 익스하면 된다.

```php
function safe_iconv($in_charset, $out_charset, $str)
{
    $result = @iconv($in_charset, $out_charset, $str);

    if ($result === false) {
        throw new Exception("iconv conversion failed: Detected an illegal character in input string");
    }
    return $result;
}

$dummy = str_repeat("A", 1098);
try {
    $passcord = safe_iconv("UTF-8", "ISO-2022-CN-EXT", $passcord);
} catch (Exception $e) {
    header("location:index.html");
    echo "redirected";
    exit();
} finally {
    $passcord = iconv("UTF-8", "ISO-2022-CN-EXT", $passcord);
    $passcord_hex = bin2hex($passcord);
    error_log("Passcord: " . $passcord_hex);
    if (strlen($passcord_hex) >= 8) {
        $fourth_byte_hex = substr($passcord_hex, 6, 2);
        $fourth_byte_value = hexdec($fourth_byte_hex);

        if ($fourth_byte_value >= 0x48 && $fourth_byte_value <= 0x4C) {
            header("location:index.html");
            echo "redirected";
            exit();
        } else {
            error_log("OK");
        }
    } else {
        header("location:index.html");
        echo "redirected";
        exit();
    }
    
}
```
safe_iconv를 통해서 검증한 후 iconv를 돌린다.
iconv를 통해서 생긴 4번째 버퍼의 범위가 0x48~0x4C이면 안되고 이를 만족하는 문자는 0x4F(M) 밖에 없다.

湿(젖을 습) 문자를 입력해주면 문제가 풀린다.

추가로 대회 이후 풀으신 분들에게 물어본 결과 다양한 한자가 나왔다.

- 편안할 안(安)
- 꾸짖을 갈(喝) ~~갈!!!~~

![alt](./res/OTwYD4A.png)

☑ cce2024{d82e4e7f1882be6a45b603ad2a552e513f680d2c25547aa3cdcd80f0edbabd4f}

# TLS_Ninja
## 개요
ninja_.pcap 파일, SSLKEYLOGFILE.log 파일이 주어진다. 이거를 이용해서 https 패킷을 열어보면 문제가 풀릴 것 같다.

## 풀이
![alt](./res/WQU00lk.png)
Edit > Preferences > Protocols > TLS 에 들어가면 Secret Log File Name을 설정할 수 있다. SSLKEYLOGFILE.log에 연결시켜주면 TLS 패킷이 복호화되게 된다.
![alt](./res/dWXMWkX.png)
HTTP 요청 마지막에서 플래그가 들어 있는 요청을 찾을 수 있다.

☑ cce2024{acf17d13de1f434e24b88d82e448fc6bfc3acf9ad4c389deef2907af00620c9e586f65546ae3756f165624b7f6a47a97}